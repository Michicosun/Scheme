# scheme-advanced

**Эту задачу нужно делать после [scheme-basic](../basic/README.md)**.

Осталось добавить в наш интерпретатор поддержку `if`, переменных и лямбда-функций с захватом контекста.

## If

Работает как if :D Возможны 2 формы записи.

* `(if condition true-branch)`
* `(if condition true-branch false-branch)`

Сначала вычисляет `condition` и проверяет значение на истинность
(с.м. определение истинности). Затем вычисляет либо `true-branch`, либо `false-branch` и возвращает как результат
всего `if`-а.

## Переменные

Поддержка переменных реализована с помощью особых форм `define` и `set!`.

```scheme
$ (define x 1)
> ()
$ x
> 1
```

Обратите внимание на возвращаемое значение `define`. Команда `set!` используется для изменения значения **существующей**
переменной:

```scheme
$ (define x 1)
> ()
$ (set! x 2)
$ x
> 2
$ (set1 y 1)
> NameError
```

Еще есть особые формы `set-car!` и `set-cdr!`. C их семантикой предлагается разобраться самостоятельно.

## Лямбда-функции

Синтаксис:

* `(lambda (x) (+ 1 x))`
* `(lambda (x y) (* y x))`
* `(lambda (x) (set! x (* x 2)) (+ 1 x))`
* `(lambda () 1)`

Создаёт новую функцию. Сначала перечисляется список аргументов функции, затем её тело. Тело может состоять из нескольких
выражений, в этом случае они вычисляются по порядку а результат последнего выражения становится результатом функции.

Запись `(define (fn-name <args>) <body>)` эквивалентна
`(define fn-name (lambda (<args>) <body>))`. То есть, `(define (inc x) (+ x 1))` - создаёт новую функцию `inc`.

## Захват контекста

### Lambda capture in C++

Также возможен и захват контекста. Синтаксис примерно совпадает с C++:

```c++
auto Range(int x) {
  return [x] () mutable {
    ++x;
    return x;
  };
}

void F() {
  auto r = Range(10);

  std::cout << r() << std::endl; // 11
  std::cout << r() << std::endl; // 12
}
```

В **Scheme**:

```scheme
$ (define range
    (lambda (x)
      (lambda ()
        (set! x (+ x 1))
        x)))

$ (define my-range (range 10))

$ (my-range)
> 11

$ (my-range)
> 12
```

Вложенных scope может быть сколь угодно много.

## Работа с памятью

В отличие от предыдущих подзадач, в этой возможен сценарий, когда два объекта ссылаются друг на друга ("циклические
ссылки"). Как вы знаете, `std::shared_ptr` в таком случае не обеспечивает корректного удаления.

Последней частью этого задания является реализация сборки мусора с учетом циклических ссылок.

Детали будут обсуждаться на семинарах.