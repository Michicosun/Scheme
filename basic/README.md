# scheme-basic

**Эту задачу нужно делать после [scheme-parser](../parser/README.md)**.

В этой части мы научимся вычислять простейшие выражения, а именно такие, которые не содержат переменных и
лямбда-функций.

## Что проверяется в этой задаче?

### 1. Особая форма quote

В языке **Scheme** существует ряд так называемых "особых форм". Одной из них является `quote` - операция, которая при
вычислении просто возвращает свой аргумент. Также нужно поддержать специальный токен `'` - это синтаксический сахар
для `(quote ...)`.

Примеры использования:

```scheme
$ '(+ 1 2)
> (+ 1 2)

$ (quote (+ 1 2))
> (+ 1 2)
```

### 2. Integer

В файле [test_integer.cpp](./test_integer.cpp) вы найдете функции, которые нужно реализовать. Понять их смысл несложно из контекста.
Обратите внимание, что многие из них работают не с двумя аргументами, а со списками произвольной (в том числе нулевой)
длины.

Для представления чисел используйте целочисленный тип `int64_t`, считайте, что переполнение не происходит.

### 3. Boolean

Добавьте в вашу реализацию еще один тип - boolean. Он имеет два возможных значения: `#t` и `#f`. В
файле [test_boolean.cpp](./test_boolean.cpp) вы найдете все функции, которые нужно реализовать.

В тестах вы найдете функции `and`, `or` - логические выражения с _short-circuit evaluation_.

* `(and)`, `(and (= 2 2) (> 2 1))`
* `(or #t)`, `(or #t (crash everything))`

Работают похоже на `&&` и `||` в C++. Вычисляют аргументы по порядку, останавливаясь когда значение всего выражения уже
не может поменяться. Их можно рассматривать как еще две особые формы.

### 4. List

Аналогично, пишем функции, которые есть в [test_list.cpp](./test_list.cpp).

## Обработка ошибок

Ваш интерпретатор должен различать 3 вида ошибок:

1. `SyntaxError`: ошибки синтаксиса. Возникают когда программа не соответствует формальному синтаксису языка. Или когда
   программа неправильно использует особые формы.


2. `RuntimeError`: ошибки обращения к неопределённым переменным.


3. `NameError`: ошибки времени исполнения. К этим ошибкам относятся все остальные ошибки которые могу возникнуть во
   время выполнения программы. Например: неправильное количество аргументов передано в функцию, неправильный тип
   аргумента.

**При этом на любых входных данных никаких других исключений из вашего интерпретатора выбрасываться не должно.**

## Подсказки

### Как организовать процесс вычисления

* Постарайтесь избежать наличия в коде if-ов на каждый тип функции, так как их довольно много.

  Вспомните пример с обработчиками событий, который разбирался на прошлом семинаре. В нем мы пришли к выводу, что если
  интерфейс всех классов в дереве наследования одинаковый и не меняется часто, то виртуальные функции предпочтительнее,
  чем явная диспетчеризация в коде (с помощью `dynamic_cast` или `enum`-ов). Используйте такой дизайн в вашем решении.


* Напомним, что число вычисляется в себя, а пара и список - нет, они должны являться аргументами функций.

```scheme
$ 1
> 1

$ (1 2)
> RuntimeError

$ (1 . 2)
> RuntimeError
```

* Символ удобно сделать вычисляемым в некий объект функции, в который потом можно было бы передать аргументы и получить
  результат.

* В реализации вам может быть удобно работать со списком как с вектором, для этого можно написать хелпер,
  трансформирующий одно представление в другое.

* Функции часто делают похожие вещи, например, валидируют число и типы своих аргументов. Постарайтесь избежать
  дублирования кода, создавайте необходимые хелперы без стеснения.

### Организация кода

* Вы вольны менять любые файлы `*.h` и `*.cpp` в директории `scheme`, в том числе удалять и создавать новые. Нельзя
  удалять только `error.h`, `parser.h` и `tokenizer.h`, так как они включаются тестами. В заготовке решения представлен лишь один из возможных вариантов
  декомпозиции.

* После добавления или удаления файла `*.cpp` нужно обновить кэш CMake.

### Тестирование

* Тесты на парсер и токенайзер устроены также, как и в прошлых задачах (см. соответствующие директории).

* Тесты в подзадачах `basic` и `advanced` используют вспомогательный класс `SchemeTest`, который находится в директории [test](../test). Из него вы поймете, какой интерфейс должен предоставлять ваш интерпретатор и как должны называться типы ошибок.

* Дополнительно собирается таргет `scheme-repl`, который состоит из [repl/main.cpp](../repl/main.cpp) и
  ваших файлов с решениями. Он не участвует в тестировании на сервере, но может быть полезен вам при отладке.
