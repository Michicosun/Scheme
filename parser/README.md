# scheme-parser

**Эту задачу нужно делать после [scheme-tokenizer](../tokenizer/README.md)**.

Вам нужно написать парсер для языка scheme. Парсер должен принимать последовательность токенов и строить по ним
синтаксическое дерево.

Синтаксическое дерево должно состоять из наследников класса `Object`.

Код токенизатора нужно переиспользовать из предыдущей задачи, используя `#include "tokenizer.h"`.

## Синтаксис scheme

* В простом случае выражения языка состоят из одного числа, boolean-а или идентификатора. В этом случае дерево разбора
  состоит из одной вершины - числа или идентификатора. Для представления числа нужно сделать отдельный класс,
  наследник `Object`. Для представления идентификатора тоже нужно сделать отдельный класс.

```
5
+
foo-bar
```

* Выражение может быть парой. Пара обозначается круглыми скобками с точкой между двумя элементами. Для пары тоже нужно
  завести отдельный класс. Например, для выражения `(1 . 2)` должно строиться дерево из 3-х элементов. Корнем дерева
  является пара с двумя потомками.


* Выражение может быть списком. Список это одна из двух сущностей:

    1. Пустой список. Обозначается пустыми скобочками - (). Можно думать, что это объект-константа со специальной
       семантикой.
    2. Пара, в которой второй элемент это список. В этом случае первый элемент пары называется головой (head) списка, а
       второй - хвостом (tail).

Из этого определения следует, что список из трех элементов можно записать так:

```
(1 . (2 . (3 . ())))

 pair => pair => pair => ()
  |       |       |
  1       2       3
```

Однако так записывать списки неудобно и разработчики языка добавили сокращенную запись:

```
(1 2 3)
```

Так записывается "правильный" список (proper list).

В языке также есть поддержка "неправильных" списков (improper list). В таком списке второй элемент самой вложенной пары
не является пустым списком.

```
(1 . (2 . 3))
pair => pair => 3
  |       |
  1       2
```

Для таких списков тоже есть сокращенная запись:

```
(1  2 . 3)
```

Элементы списков могут любыми корректными выражениями

```
((1 . 2) (3 4) 5)
(1 () (2 3 4) 5)
```

**От вашего задания требуется, чтобы пустой список был представлен с помощью nullptr.**

## Рекурсивный спуск

Грамматика языка `scheme` лежит в классе `LL(1)`. Это значит, что можно написать рекурсивный алгоритм разбора, который
заглядывает всего на один токен вперёд.

В авторском решении удалось обойтись всего двумя взаимно рекурсивными функциями:
`Read` и `ReadList`.

- `Read` читает произвольное значение.
- `ReadList` читает список, пару или список с точкой в конце.

`Read` заглядывает на 1 токен вперёд.

1. Если стоит число или имя, то выражение состоит из одного элемента.
2. Если там стоит `(`, то нужно вызвать рекурсивно `ReadList`.

`ReadList` в цикле вызывает `Read`, пока не встретит `)`.

## Обработка ошибок

Ваш парсер должен проверять входной поток на корректность. В случае если поток токенов не соответствует корректному
выражению, нужно бросать исключение `SyntaxError`.
